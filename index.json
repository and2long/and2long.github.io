
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    [{"authors":null,"categories":null,"content":"Flutter里的国际化，简言之，分为两大步：\n创建本地化资源。 创建本地化资源代理，并配置到APP入口函数。 应用内切换语言，关键点有两个：\n指定应用的语言：设置 MaterialApp 的 locate 参数。 取得当前语言对应的本地化资源文件：Localizations.of\u0026lt;S\u0026gt;(context, S)。 Localizations 继承自 StatefulWidget ，内部属性 locale 有变化，child 就会重建。\n以下，为国际化代码的具体实现：\n前提 在 pubspec.yaml 文件中添加它和 intl作为依赖\nflutter pub add flutter_localizations --sdk=flutter flutter pub add intl:any 最终的 pubspec.yaml 文件中形如：\ndependencies: flutter: sdk: flutter flutter_localizations: sdk: flutter intl: any 1. 创建本地化资源 1.1 创建本地化资源接口，声明需要翻译的字段。 使用接口定义待翻译字段的好处是：实现类/子类 必须对抽象字段进行赋值，否则编译器会报错。 相比之下，字典的方式，某个 key 没有赋值，编译器检查不出来，而且，哪些 key 是有用的，哪些 key 没用了，也不好确定。\n/// 本地化资源 基类 abstract class S { /// 本地化资源代理对象 static const LocalizationsDelegate delegate = ProjectLocalizationsDelegate(); /// 根据上下文中的 [Locale] 取得对应的本地化资源。 static S of(BuildContext context) { return Localizations.of\u0026lt;S\u0026gt;(context, S)!; } /// 支持的语言。 /// 如果本地没有保存的语言配置参数，APP会默认使用第一个作为默认语言。 static List\u0026lt;Locale\u0026gt; supportedLocales = [ const Locale(\u0026#39;en\u0026#39;), const Locale(\u0026#39;ja\u0026#39;), const Locale(\u0026#39;zh\u0026#39;) ]; // 不需要翻译的字段，直接赋值。 static String appName = \u0026#39;AppName\u0026#39;; static String english = \u0026#39;English\u0026#39;; static String japanese = \u0026#39;日本語\u0026#39;; static String simpleChinese = \u0026#39;简体中文\u0026#39;; static Map\u0026lt;String, String\u0026gt; localeSets = { \u0026#39;en\u0026#39;: english, \u0026#39;ja\u0026#39;: japanese, \u0026#39;zh\u0026#39;: simpleChinese }; // 需要翻译的字段追加到下面，在子类中进行赋值。 String get cancel; String get ok; String get readAndAgree; String get privacyPolicy; String get termsOfService; String get me; String get settingsLanguage; } 1.2 创建指定语言的资源类（实现上一步中的接口），对接口中的成员变量进行赋值。 /// 英文 class ProjectLocalizationsEN implements S { @override String get cancel =\u0026gt; \u0026#34;Cancel\u0026#34;; @override String get ok =\u0026gt; \u0026#34;OK\u0026#34;; } /// 中文 class ProjectLocalizationsZH implements S { @override String get cancel =\u0026gt; \u0026#34;取消\u0026#34;; @override String get ok =\u0026gt; \u0026#34;确定\u0026#34;; } /// 日文 class ProjectLocalizationsJA implements S { @override String get cancel =\u0026gt; \u0026#34;キャンセル\u0026#34;; @override String get ok =\u0026gt; \u0026#34;確定\u0026#34;; } 2. 创建本地化资源代理 2.1 创建本地化资源代理类（继承 LocalizationsDelegate），重写 load 方法，根据 locale 返回对应语言的资源。 /// 项目本地化资源代理 class ProjectLocalizationsDelegate extends LocalizationsDelegate\u0026lt;S\u0026gt; { const ProjectLocalizationsDelegate(); @override bool isSupported(Locale locale) =\u0026gt; true; @override Future\u0026lt;S\u0026gt; load(Locale locale) { return SynchronousFuture\u0026lt;S\u0026gt;(getMaterialTranslation(locale)); } @override bool shouldReload(ProjectLocalizationsDelegate old) =\u0026gt; false; /// 根据 locale 得到对应的本地化资源 S getMaterialTranslation(Locale locale) { switch (locale.languageCode) { case \u0026#39;en\u0026#39;: return ProjectLocalizationsEN(); case \u0026#39;zh\u0026#39;: return ProjectLocalizationsZH(); case \u0026#39;ja\u0026#39;: return ProjectLocalizationsJA(); default: return ProjectLocalizationsEN(); } } } 2.2 在程序入口 MaterialApp 中的 localizationsDelegates 参数中，加入自己创建的本地化资源代理类。 import \u0026#39;package:flutter_localizations/flutter_localizations.dart\u0026#39;; class MyApp extends StatelessWidget { const MyApp({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return Consumer\u0026lt;LocaleStore\u0026gt;(builder: (context, localeStore, _) { return OKToast( movingOnWindowChange: false, child: MaterialApp( onGenerateTitle: (context) =\u0026gt; S.appName, // 不需要翻译的字段，可以直接类名调用。 theme: AppTheme.lightTheme(context), localizationsDelegates: const [ GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, // 项目本地化资源代理 S.delegate, ], // 支持的语言 supportedLocales: S.supportedLocales, // 指定语言，如果 localStore 里没有保存的语言参数，则直接使用 S 文件中配置的第一个语言。 locale: localeStore.languageCode == null ? S.supportedLocales.first : Locale(localeStore.languageCode!), routes: RouteMap.routes, home: const HomePage(), builder: (context, child) =\u0026gt; GestureDetector( onTap: () =\u0026gt; CommonUtils.hideKeyboard(context), child: child, ), ), ); }); } } 配置完成，开始使用： 不需要翻译的字段，使用方式： S.appName 支持多语言的字段，使用方式： S.of(context).ok S.of(context). cancel ","date":1677507693,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1677507693,"objectID":"37aaf278d2da4dc308d3d1e2a806c169","permalink":"https://and2long.github.io/post/flutter%E5%9B%BD%E9%99%85%E5%8C%96%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/","publishdate":"2023-02-27T22:21:33+08:00","relpermalink":"/post/flutter%E5%9B%BD%E9%99%85%E5%8C%96%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/","section":"post","summary":"Flutter里的国际化，简言之，分为两大步：\n创建本地化资源。 创建本地化资源代理，并配置到APP入口函数。 应用内切换语言，关键点有两个：\n指定应用的语言：设置 MaterialApp 的 locate 参数。 取得当前语言对应的本地化资源文件：Localizations.of\u003cS\u003e(context, S)。 Localizations 继承自 StatefulWidget ，内部属性 locale 有变化，child 就会重建。\n以下，为国际化代码的具体实现：\n前提 在 pubspec.yaml 文件中添加它和 intl作为依赖\nflutter pub add flutter_localizations --sdk=flutter flutter pub add intl:any 最终的 pubspec.yaml 文件中形如：\ndependencies: flutter: sdk: flutter flutter_localizations: sdk: flutter intl: any 1. 创建本地化资源 1.1 创建本地化资源接口，声明需要翻译的字段。 使用接口定义待翻译字段的好处是：实现类/子类 必须对抽象字段进行赋值，否则编译器会报错。 相比之下，字典的方式，某个 key 没有赋值，编译器检查不出来，而且，哪些 key 是有用的，哪些 key 没用了，也不好确定。\n/// 本地化资源 基类 abstract class S { /// 本地化资源代理对象 static const LocalizationsDelegate delegate = ProjectLocalizationsDelegate(); /// 根据上下文中的 [Locale] 取得对应的本地化资源。 static S of(BuildContext context) { return Localizations.of\u003cS\u003e(context, S)!; } /// 支持的语言。 /// 如果本地没有保存的语言配置参数，APP会默认使用第一个作为默认语言。 static List\u003cLocale\u003e supportedLocales = [ const Locale('en'), const Locale('ja'), const Locale('zh') ]; // 不需要翻译的字段，直接赋值。 static String appName = 'AppName'; static String english = 'English'; static String japanese = '日本語'; static String simpleChinese = '简体中文'; static Map\u003cString, String\u003e localeSets = { 'en': english, 'ja': japanese, 'zh': simpleChinese }; // 需要翻译的字段追加到下面，在子类中进行赋值。 String get cancel; String get ok; String get readAndAgree; String get privacyPolicy; String get termsOfService; String get me; String get settingsLanguage; } 1.2 创建指定语言的资源类（实现上一步中的接口），对接口中的成员变量进行赋值。 /// 英文 class ProjectLocalizationsEN implements S { @override String get cancel =\u003e \"Cancel\"; @override String get ok =\u003e \"OK\"; } /// 中文 class ProjectLocalizationsZH implements S { @override String get cancel =\u003e \"取消\"; @override String get ok =\u003e \"确定\"; } /// 日文 class ProjectLocalizationsJA implements S { @override String get cancel =\u003e \"キャンセル\"; @override String get ok =\u003e \"確定\"; } 2. 创建本地化资源代理 2.1 创建本地化资源代理类（继承 LocalizationsDelegate），重写 load 方法，根据 locale 返回对应语言的资源。 /// 项目本地化资源代理 class ProjectLocalizationsDelegate extends LocalizationsDelegate\u003cS\u003e { const ProjectLocalizationsDelegate(); @override bool isSupported(Locale locale) =\u003e true; @override Future\u003cS\u003e load(Locale locale) { return SynchronousFuture\u003cS\u003e(getMaterialTranslation(locale)); } @override bool shouldReload(ProjectLocalizationsDelegate old) =\u003e false; /// 根据 locale 得到对应的本地化资源 S getMaterialTranslation(Locale locale) { switch (locale.languageCode) { case 'en': return ProjectLocalizationsEN(); case 'zh': return ProjectLocalizationsZH(); case 'ja': return ProjectLocalizationsJA(); default: return ProjectLocalizationsEN(); } } } 2.2 在程序入口 MaterialApp 中的 localizationsDelegates 参数中，加入自己创建的本地化资源代理类。 import 'package:flutter_localizations/flutter_localizations.dart'; class MyApp extends StatelessWidget { const MyApp({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return Consumer\u003cLocaleStore\u003e(builder: (context, localeStore, _) { return OKToast( movingOnWindowChange: false, child: MaterialApp( onGenerateTitle: (context) =\u003e S.appName, // 不需要翻译的字段，可以直接类名调用。 theme: AppTheme.lightTheme(context), localizationsDelegates: const [ GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, // 项目本地化资源代理 S.delegate, ], // 支持的语言 supportedLocales: S.supportedLocales, // 指定语言，如果 localStore 里没有保存的语言参数，则直接使用 S 文件中配置的第一个语言。 locale: localeStore.languageCode == null ? S.supportedLocales.first : Locale(localeStore.languageCode!), routes: RouteMap.routes, home: const HomePage(), builder: (context, child) =\u003e GestureDetector( onTap: () =\u003e CommonUtils.hideKeyboard(context), child: child, ), ), ); }); } } 配置完成，开始使用： 不需要翻译的字段，使用方式： S.appName 支持多语言的字段，使用方式： S.of(context).ok S.of(context). cancel ","tags":["Flutter"],"title":"【Flutter】国际化代码实现","type":"post"},{"authors":null,"categories":null,"content":" 输入大写字母R，并选中。 切换字体为 Wingdings2。 字母R就变成了勾选框。\n","date":1649954859,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1649954859,"objectID":"04a7e39483d56ef44b1c7b9cc5a7c39d","permalink":"https://and2long.github.io/post/excel%E4%B8%AD%E8%BE%93%E5%85%A5%E5%8B%BE%E9%80%89%E6%A1%86/","publishdate":"2022-04-14T16:47:39Z","relpermalink":"/post/excel%E4%B8%AD%E8%BE%93%E5%85%A5%E5%8B%BE%E9%80%89%E6%A1%86/","section":"post","summary":" 输入大写字母R，并选中。 切换字体为 Wingdings2。 字母R就变成了勾选框。\n","tags":null,"title":"Excel中输入勾选框","type":"post"},{"authors":null,"categories":null,"content":"将\ngoogle() mavenCentral() 修改为：\nmaven { url \u0026#39;https://maven.aliyun.com/repository/google\u0026#39; } maven { url \u0026#39;https://maven.aliyun.com/repository/central\u0026#39; } 替换过期jcenter地址：\nmaven { url \u0026#39;https://maven.aliyun.com/repository/jcenter\u0026#39; } ","date":1647872493,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1647872493,"objectID":"f5a277a6c7be36fa69d4b7bd5cb12a6a","permalink":"https://and2long.github.io/post/%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E4%BF%AE%E6%94%B9gradle%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80/","publishdate":"2022-03-21T22:21:33+08:00","relpermalink":"/post/%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E4%BF%AE%E6%94%B9gradle%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80/","section":"post","summary":"将\ngoogle() mavenCentral() 修改为：\nmaven { url 'https://maven.aliyun.com/repository/google' } maven { url 'https://maven.aliyun.com/repository/central' } 替换过期jcenter地址：\nmaven { url 'https://maven.aliyun.com/repository/jcenter' } ","tags":["Android","gradle"],"title":"安卓项目修改gradle镜像地址","type":"post"},{"authors":null,"categories":null,"content":"M1 平台 pod install 出错 方法1：命令前加 arch -x86_64 pod install 或者 pod update 前面加 arch -x86_64\n如： arch -x86_64 pod install arch -x86_64 pod update\n方法2: 卸载 cocoapods，用 brew 重新安装 cocoapods gem list --local | grep cocoapods | awk \u0026#39;{print $1}\u0026#39; | xargs sudo gem uninstall brew install cocoapods\n","date":1647027466,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1647027466,"objectID":"cda092849856b066b71ac67db819f689","permalink":"https://and2long.github.io/post/m1%E5%B9%B3%E5%8F%B0-pod-install-%E5%87%BA%E9%94%99/","publishdate":"2022-03-11T19:37:46Z","relpermalink":"/post/m1%E5%B9%B3%E5%8F%B0-pod-install-%E5%87%BA%E9%94%99/","section":"post","summary":"M1 平台 pod install 出错 方法1：命令前加 arch -x86_64 pod install 或者 pod update 前面加 arch -x86_64\n如： arch -x86_64 pod install arch -x86_64 pod update\n方法2: 卸载 cocoapods，用 brew 重新安装 cocoapods gem list --local | grep cocoapods | awk '{print $1}' | xargs sudo gem uninstall brew install cocoapods\n","tags":["M1"],"title":"M1 平台 pod install 出错","type":"post"},{"authors":null,"categories":null,"content":"生成 release 包 Qt Creator 左下角切换为 Release 模式，然后点击左下角 Build 锤子🔨图标。\n定位到构建文件夹 Build directory 可在 Projects -\u0026gt; Build Settings 中找到：Build directory。\n使用 macdeployqt 工具打包 .app 文件 工具所在目录：~/Qt/6.2.3/macos/bin\n./macdeployqt $Build directory$/***.app\n","date":1646421876,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1646421876,"objectID":"3ce059abd82882bbb94c08f951544e7f","permalink":"https://and2long.github.io/post/qt%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85dmg%E6%B5%81%E7%A8%8B/","publishdate":"2022-03-04T19:24:36Z","relpermalink":"/post/qt%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85dmg%E6%B5%81%E7%A8%8B/","section":"post","summary":"生成 release 包 Qt Creator 左下角切换为 Release 模式，然后点击左下角 Build 锤子🔨图标。\n定位到构建文件夹 Build directory 可在 Projects -\u003e Build Settings 中找到：Build directory。\n使用 macdeployqt 工具打包 .app 文件 工具所在目录：~/Qt/6.2.3/macos/bin\n./macdeployqt $Build directory$/***.app\n","tags":["Qt"],"title":"Qt应用Mac平台打包流程","type":"post"},{"authors":null,"categories":null,"content":"Effect 相关 官方文档：使用 Effect Hook 结合例子说明，非常推荐！useEffect-数据获取 自定义 Hook ","date":1645298631,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1645298631,"objectID":"13b38e59f2e516789a4d81d1f57c28e8","permalink":"https://and2long.github.io/post/react-%E6%96%87%E7%AB%A0%E7%B2%BE%E9%80%89/","publishdate":"2022-02-19T19:23:51Z","relpermalink":"/post/react-%E6%96%87%E7%AB%A0%E7%B2%BE%E9%80%89/","section":"post","summary":"Effect 相关 官方文档：使用 Effect Hook 结合例子说明，非常推荐！useEffect-数据获取 自定义 Hook ","tags":["React"],"title":"React 文章精选","type":"post"},{"authors":null,"categories":null,"content":"查看 npm 配置 npm config ls -l\nnpm 换源 默认安装源为https://registry.npmjs.org，更换为国内镜像地址之后，可以加快下载速度。\n以下两种方式都可以。推荐第二种方式，一次设置，所有项目生效。\n下载依赖库时指定源： npm install aws-amplify --registry=https://registry.npmmirror.com 全局修改默认源： npm config set registry https://registry.npmmirror.com 检查当前源： npm config get registry\nnpm 查看全局安装路径 npm root -g\npnpm 安装 npm install -g pnpm 检查存储路径 pnpm store path 设置镜像地址 pnpm set registry \u0026#34;https://registry.npmmirror.com\u0026#34; ","date":1644851940,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1644851940,"objectID":"e624e2935b6aa373e3fc87be742763e3","permalink":"https://and2long.github.io/post/npm-%E7%9B%B8%E5%85%B3/","publishdate":"2022-02-14T15:19:00Z","relpermalink":"/post/npm-%E7%9B%B8%E5%85%B3/","section":"post","summary":"查看 npm 配置 npm config ls -l\nnpm 换源 默认安装源为https://registry.npmjs.org，更换为国内镜像地址之后，可以加快下载速度。\n以下两种方式都可以。推荐第二种方式，一次设置，所有项目生效。\n下载依赖库时指定源： npm install aws-amplify --registry=https://registry.npmmirror.com 全局修改默认源： npm config set registry https://registry.npmmirror.com 检查当前源： npm config get registry\nnpm 查看全局安装路径 npm root -g\npnpm 安装 npm install -g pnpm 检查存储路径 pnpm store path 设置镜像地址 pnpm set registry \"https://registry.npmmirror.com\" ","tags":["npm"],"title":"npm 相关","type":"post"},{"authors":null,"categories":null,"content":" 功能描述 命令 安装依赖包 flutter pub get 检查哪些依赖包过期 flutter pub outdated 检查项目依赖包是否支持空安全 dart pub outdated --mode=null-safety 升级依赖包 flutter pub upgrade 升级依赖包-大版本 flutter pub upgrade --major-versions 将项目代码迁移到空安全 dart migrate 自动修复代码问题 dart fix --apply 打包 Android bundle flutter build appbundle 打包 Android apks flutter build apk --split-per-abi 打包 iOS flutter build ios Debug 模式运行 flutter run Profile 模式运行 flutter run --profile Release 模式运行 flutter run --release 指定 Web 渲染模式 flutter run -d chrome --web-renderer html 发布包检查 flutter packages pub publish --dry-run 发布包 flutter packages pub publish --server=https://pub.dartlang.org ","date":1644678000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1644678000,"objectID":"43b39a5ba15b75682864eac5a16b605c","permalink":"https://and2long.github.io/post/flutter-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","publishdate":"2022-02-12T15:00:00Z","relpermalink":"/post/flutter-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","section":"post","summary":" 功能描述 命令 安装依赖包 flutter pub get 检查哪些依赖包过期 flutter pub outdated 检查项目依赖包是否支持空安全 dart pub outdated --mode=null-safety 升级依赖包 flutter pub upgrade 升级依赖包-大版本 flutter pub upgrade --major-versions 将项目代码迁移到空安全 dart migrate 自动修复代码问题 dart fix --apply 打包 Android bundle flutter build appbundle 打包 Android apks flutter build apk --split-per-abi 打包 iOS flutter build ios Debug 模式运行 flutter run Profile 模式运行 flutter run --profile Release 模式运行 flutter run --release 指定 Web 渲染模式 flutter run -d chrome --web-renderer html 发布包检查 flutter packages pub publish --dry-run 发布包 flutter packages pub publish --server=https://pub.dartlang.org ","tags":["Flutter"],"title":"Flutter 常用命令","type":"post"},{"authors":null,"categories":null,"content":"定义函数 // 函数返回两个数中较大的那个数 int max(int num1, int num2) { // 局部变量声明 int result; if (num1 \u0026gt; num2) result = num1; else result = num2; return result; } 函数声明 函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。\n针对上面定义的函数 max()，以下是函数声明：\nint max(int num1, int num2); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：\nint max(int, int); 当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。\n参数的默认值 当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。\nint sum(int a, int b=20) { int result; result = a + b; return (result); } Lambda 函数与表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。\nLambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:\n[capture](parameters)-\u0026gt;return-type{body} 例如：\n[](int x, int y) -\u0026gt; int { int z = x + y; return z + x; } 如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。\n在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：\n[] // 沒有定义任何变量。使用未定义变量会引发错误。 [x, \u0026amp;y] // x以传值方式传入（默认），y以引用方式传入。 [\u0026amp;] // 任何被使用到的外部变量都隐式地以引用方式加以引用。 [=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。 [\u0026amp;, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。 [=, \u0026amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 另外有一点需要注意。对于[=]或[\u0026amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：\n[this]() { this-\u0026gt;someFunc(); }(); 三种向函数传递参数的方式 调用类型 描述 传值调用 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 传值调用 // 函数定义 void swap(int x, int y) { int temp; temp = x; /* 保存 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 x 赋值给 y */ return; } #include \u0026lt;iostream\u0026gt; using namespace std; // 函数声明 void swap(int x, int y); int main () { // 局部变量声明 int a = 100; int b = 200; cout \u0026lt;\u0026lt; \u0026#34;交换前，a 的值：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;交换前，b 的值：\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; // 调用函数来交换值 swap(a, b); cout \u0026lt;\u0026lt; \u0026#34;交换后，a 的值：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;交换后，b 的值：\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 编译执行结果：\n交换前，a 的值： 100 交换前，b 的值： 200 交换后，a 的值： 100 交换后，b 的值： 200 指针调用 void swap(int *x, int *y) { int temp; temp = *x; /* 保存地址 x 的值 */ *x = *y; /* 把 y 赋值给 x */ *y = temp; /* 把 x 赋值给 y */ return; } #include \u0026lt;iostream\u0026gt; using namespace std; // 函数声明 void swap(int *x, int *y); int main () { // 局部变量声明 int a = 100; int b = 200; cout \u0026lt;\u0026lt; \u0026#34;交换前，a 的值：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;交换前，b 的值：\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; /* 调用函数来交换值 * \u0026amp;a 表示指向 a 的指针，即变量 a 的地址 * \u0026amp;b 表示指向 b 的指针，即变量 b 的地址 */ swap(\u0026amp;a, \u0026amp;b); cout \u0026lt;\u0026lt; \u0026#34;交换后，a 的值：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;交换后，b 的值：\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 编译执行结果：\n交换前，a 的值： 100 交换前，b 的值： 200 交换后，a 的值： 200 交换后，b 的值： 100 引用调用 // 函数定义 void swap(int \u0026amp;x, int \u0026amp;y) { int temp; temp = x; /* 保存地址 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 x 赋值给 y */ return; } #include \u0026lt;iostream\u0026gt; using namespace std; // 函数声明 void swap(int \u0026amp;x, int \u0026amp;y); int main () { // 局部变量声明 int a = 100; int b = 200; cout \u0026lt;\u0026lt; \u0026#34;交换前，a 的值：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;交换前，b 的值：\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; /* 调用函数来交换值 */ swap(a, b); cout \u0026lt;\u0026lt; \u0026#34;交换后，a 的值：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;交换后，b 的值：\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 编译执行结果：\n交换前，a 的值： 100 交换前，b 的值： 200 交换后，a 的值： 200 交换后，b 的值： 100 原文链接\n","date":1643119200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1643119200,"objectID":"28350d6e5e8f03a9171cd4526f1cf102","permalink":"https://and2long.github.io/post/c++%E5%87%BD%E6%95%B0/","publishdate":"2022-01-25T14:00:00Z","relpermalink":"/post/c++%E5%87%BD%E6%95%B0/","section":"post","summary":"定义函数 // 函数返回两个数中较大的那个数 int max(int num1, int num2) { // 局部变量声明 int result; if (num1 \u003e num2) result = num1; else result = num2; return result; } ","tags":["C++"],"title":"C++函数","type":"post"},{"authors":null,"categories":null,"content":"通配符选择器 * 匹配所有控件。\n* { } 类型选择器 通过控件类型来匹配控件（包括子类）。\nQPushButton { } 匹配所有 QPushButton 及其子类的控件。\n类选择器 通过控件类型来匹配控件（不包括子类）。\n.QPushButton { } 只匹配所有 QPushButton 控件，不包含子类。\nID选择器 通过 objectName 来匹配控件。\n#hehe { } 匹配所有 objectName 为 hehe 的控件。\nobjectName 可通过 setObjectName 方法设置。\n属性选择器 通过属性值来匹配控件。控件类型[属性名=“属性值”]\nQPushButton[level=\u0026#34;warning\u0026#34;] { } 匹配所有 QPushButton 控件，并且 level 属性值为\u0026#34;warning\u0026#34;。\n属性可通过 setProperty 方法设置。\n后代选择器 匹配 父控件（直接或者间接）的子控件。\nQDialog QPushButton { } 匹配所有 QDialog 中直接或间接包含的 QPushButton 控件。\n子选择器 匹配父控件直接包含的子控件。\nQDialog\u0026gt;QPushButton { } 匹配所有 QDialog 中直接包含的 QPushButton 控件。\n子控件选择器 用来筛选一个复合控件上的子控件。 复合控件::子控件\n常用子控件： QCheckBox, QRadioButton ::indicator QComboBOx ::drop-down QSpinBox, QDateEdit, QRimeEdit, QDateTimeEdit ::up-button ::down-button ::up-arrow ::down-arrow 伪状态选择器 限制控件只能在某种状态下，被样式表作用。\nQPushButton:hover { } QPushButton 被鼠标经过时的样式。\n常见的伪状态： :checked button控件被选中 :unchecked button控件未被选中 :hover 控件被鼠标放在上面 :pressed 控件被按下 :focus 控件获取焦点 :disable 控件失效 :enable 控件有效 :indeterminate checkBox或者radioButton被部分选中 :on 控件处于on状态 :off 控件处于off状态 注意 不同的控件可能有某种特定的伪状态，无法通用，具体查看官方文档。 !可以否定。:!checked 没有被选中。 可以连接使用。 :hover:checked 鼠标在上and被选中时。 以上选择器分类可以组合使用，用逗号隔开即可。 #hehe, #heihei { } ","date":1642600885,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1642600885,"objectID":"a1f399d676e88e10dcac62b022da426d","permalink":"https://and2long.github.io/post/qss%E9%80%89%E6%8B%A9%E5%99%A8/","publishdate":"2022-01-19T14:01:25Z","relpermalink":"/post/qss%E9%80%89%E6%8B%A9%E5%99%A8/","section":"post","summary":"通配符选择器 * 匹配所有控件。\n* { } ","tags":["Qt"],"title":"QSS选择器","type":"post"}]